buildscript {
    dependencies {
        classpath files('./AndroidSdkClientForJava.jar')
    }
}

import info.vividcode.android.sdk.client.*

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

String consolePortFile = project.properties["avdConsolePortFile"]

Properties props = new Properties()
project.rootProject.file('local.properties').newDataInputStream().withCloseable {
    props.load(it)
}
String androidSdkDir = props.getProperty('sdk.dir')

task('startAvd') << {
    if (consolePortFile == null)
        throw new RuntimeException('You must specify the `avdConsolePortFile` parameter')
    if (androidSdkDir == null)
        throw new RuntimeException('You must specify the `sdk.dir` in the `local.properties` file')
    Path sdkDir = Paths.get(androidSdkDir);
    AndroidSdk androidSdk = new AndroidSdk(sdkDir);
    EmulatorCommandExecutor emulatorCmd = androidSdk.emulatorCommand();
    // 既に存在する AVD の名前一覧を取得。
    List<String> avdNames = emulatorCmd.listAvds();
    // 使用する AVD の名前。
    String targetAvdName = "test2";
    // 使用しようとしている AVD が既にに存在するかどうか。
    boolean targetAvdExists = avdNames.contains(targetAvdName);

    // まだ存在しない場合は作成する。
    if (!targetAvdExists) {
        Path androidCommand = sdkDir.resolve("tools/android.bat");
        AndroidCommandExecutor androidCmdExec = new AndroidCommandExecutor(androidCommand);
        // 既にインストール済みかどうか気にせず、とりあえず必要なシステムイメージなどのインストール (アップデート)。
        AutoRespondingProcessIoHandler.Factory f = new AutoRespondingProcessIoHandler.Factory(Pattern.compile("Do you accept the license .*"), "y");
        androidCmdExec.updateSdkWithFilter("android-19", f);
        androidCmdExec.updateSdkWithFilter("sys-img-x86-android-19", f);
        // AVD 作成。
        AutoRespondingProcessIoHandler.Factory f2 = new AutoRespondingProcessIoHandler.Factory(Pattern.compile("Do you wish to create a custom hardware profile .*"), "");
        androidCmdExec.createAvd(targetAvdName, "android-19", "x86", f2);
    }

    // AVD 起動。
    logger.info('AVD: starting')
    emulatorCmd.startAvd(targetAvdName).withCloseable {
        logger.info('AVD: started')
        Avd avd = it
        // AVD のコンソールポートといろいろやり取りできる状態。

        new File(consolePortFile).text = avd.consolePort.toString()

        // adb で操作できるようになるまで待つ。
        // (あくまで adb デーモンの起動を待つだけなので、ブート完了は別に待つ必要がある。)
        AdbCommandExecutor adbCommand = androidSdk.adbCommand();
        logger.info("AVD: wait for device...");
        adbCommand.waitForDevice(avd.getConsolePort());
        logger.info("AVD: done");

        // ブート完了を待つ。
        // See: https://devmaze.wordpress.com/2011/12/12/starting-and-stopping-android-emulators/
        // See: http://android.stackexchange.com/questions/83726/how-to-adb-wait-for-device-until-the-home-screen-shows-up
        logger.info("AVD: wait for device boot complete");
        while (true) {
            String bootComplete = adbCommand.shell(avd.getConsolePort(), "getprop dev.bootcomplete");
            if (bootComplete.equals("1")) break;
            else Thread.sleep(500);
        }
        logger.info("AVD: device boot completed");
    }
}

task('killAvd') << {
    if (consolePortFile == null)
        throw new RuntimeException('You must specify the `avdConsolePortFile` parameter')

    String consolePortStr = new File(consolePortFile).text
    Avd.create(Integer.valueOf(consolePortStr)).withCloseable {
        Avd avd = it
        // 終了。
        avd.readConsoleOutput(10, TimeUnit.SECONDS)
        avd.kill()
    }
}
